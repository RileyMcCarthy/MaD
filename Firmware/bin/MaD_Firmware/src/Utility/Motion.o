#line 1 "/home/mad/Tensile-Testing-Machine/Firmware/MaD_Firmware/src/Utility/Motion.c"
#line 1 "/home/mad/Tensile-Testing-Machine/Firmware/MaD_Firmware/include/Utility/Motion.h"
#line 1 "/home/mad/flexprop/include/stdbool.h"
#line 2 "/home/mad/Tensile-Testing-Machine/Firmware/MaD_Firmware/include/Utility/Motion.h"
typedef struct MotionCommand{
    int steps;
    int feedrate;
    _Bool  last;
} MotionCommand;

void motion_enable();
void motion_disable();
void motion_clear();
_Bool  motion_add_move(int steps, int feedrate);
void motion_test_start();
void motion_test_end();
void motion_test_clear();
_Bool  motion_test_is_empty();
_Bool  motion_test_add_move(MotionCommand *command);
long motion_get_position();
long motion_get_setpoint();
#line 2 "/home/mad/Tensile-Testing-Machine/Firmware/MaD_Firmware/src/Utility/Motion.c"
#line 1 "/home/mad/Tensile-Testing-Machine/Firmware/MaD_Firmware/include/Main/MaD.h"
#line 32 "/home/mad/Tensile-Testing-Machine/Firmware/MaD_Firmware/include/Main/MaD.h"
void mad_begin();
#line 3 "/home/mad/Tensile-Testing-Machine/Firmware/MaD_Firmware/src/Utility/Motion.c"
#line 1 "/home/mad/flexprop/include/stdlib.h"
#line 4 "/home/mad/flexprop/include/stdlib.h"
#line 1 "/home/mad/flexprop/include/compiler.h"
#line 5 "/home/mad/flexprop/include/stdlib.h"
#line 1 "/home/mad/flexprop/include/sys/size_t.h"





  typedef  unsigned long  size_t;
#line 6 "/home/mad/flexprop/include/stdlib.h"
#line 1 "/home/mad/flexprop/include/sys/wchar_t.h"
#line 15 "/home/mad/flexprop/include/sys/wchar_t.h"
typedef int wchar_t;
#line 24 "/home/mad/flexprop/include/sys/wchar_t.h"
typedef struct _Mbstate {
  unsigned int total:5;
  unsigned int left:5;
  unsigned int partial:22;
} _Mbstate_t;
#line 7 "/home/mad/flexprop/include/stdlib.h"
#line 1 "/home/mad/flexprop/include/sys/null.h"
#line 8 "/home/mad/flexprop/include/stdlib.h"
#line 22 "/home/mad/flexprop/include/stdlib.h"
    double atof(const char *);
    int atoi(const char *)  __fromfile("libc/stdlib/atoi.c") ;
    long atol(const char *)  __fromfile("libc/stdlib/atoi.c") ;
    long long atoll(const char *);

  long double strtold(const char *nptr, char **endptr);
  double strtod(const char *nptr, char **endptr);
  float strtof(const char *nptr, char **endptr);

    long strtol(const char *nptr, char **endptr, int base)  __fromfile("libc/stdlib/strtol.c") ;
    unsigned long strtoul(const char *nptr, char **endptr, int base)  __fromfile("libc/stdlib/strtoul.c") ;
  long long strtoll(const char *nptr, char **endptr, int base);
  unsigned long long strtoull(const char *nptr, char **endptr, int base);


    int rand(void)  __fromfile("libc/stdlib/rand.c") ;
    void srand(unsigned int seed)  __fromfile("libc/stdlib/rand.c") ;

    void *malloc(size_t n)  __fromfile("libc/stdlib/malloc.c") ;
    void *calloc(size_t, size_t)  __fromfile("libc/stdlib/malloc.c") ;
    void *realloc(void *, size_t)  __fromfile("libc/stdlib/malloc.c") ;
    void free(void *)  __fromfile("libc/stdlib/malloc.c") ;


    int atexit(void (*func)(void))  __fromfile("libc/stdlib/exit.c") ;
     void exit(int status)  __fromfile("libc/stdlib/exit.c") ;
     void abort(void)  __fromfile("libc/stdlib/abort.c") ;
     void _Exit(int status)  __fromfile("libc/stdlib/_Exit.c") ;
   void _exit(int status);
#line 56 "/home/mad/flexprop/include/stdlib.h"
   long labs(long l);


   long long llabs(long long ll);


  typedef struct {
    int quot, rem;
  } div_t;

  typedef struct {
    long int quot, rem;
  } ldiv_t;

  typedef struct {
    long long quot, rem;
  } lldiv_t;

  div_t div(int num, int denom);
  ldiv_t ldiv(long num, long denom);
  lldiv_t lldiv(long long num, long long denom);

    void qsort(void *base, size_t nmemb, size_t size, int (*compare)(const void *, const void *))  __fromfile("libc/stdlib/qsort.c") ;
  void *bsearch(const void *key, const void *base, size_t nmemb, size_t size,
		int (*compare)(const void *, const void *));

    char *getenv(const char *name)  __fromfile("libc/stdlib/getenv.c") ;
    int putenv(const char *name)  __fromfile("libc/stdlib/putenv.c") ;


  extern int _mb_cur_max;



  int mblen(const char *s, size_t n);
  int mbtowc(wchar_t * __restrict pwc, const char * __restrict s, size_t n);
  size_t mbstowcs(wchar_t *dest, const char *src, size_t n);


  int system(const char *command);
#line 102 "/home/mad/flexprop/include/stdlib.h"
    int _itoa_prec( unsigned int x, char *buf, unsigned base, int prec );
    int _lltoa_prec( unsigned long long x, char *buf, unsigned base, int prec );
#line 4 "/home/mad/Tensile-Testing-Machine/Firmware/MaD_Firmware/src/Utility/Motion.c"
#line 1 "/home/mad/Tensile-Testing-Machine/Firmware/MaD_Firmware/lib/Queue/StaticQueue.h"
#line 1 "/home/mad/flexprop/include/stdbool.h"
#line 2 "/home/mad/Tensile-Testing-Machine/Firmware/MaD_Firmware/lib/Queue/StaticQueue.h"
#line 1 "/home/mad/flexprop/include/stdlib.h"
#line 3 "/home/mad/Tensile-Testing-Machine/Firmware/MaD_Firmware/lib/Queue/StaticQueue.h"
typedef struct StaticQueue_t {
    void *buf;
    int front;
    int rear;
    int size;
    int max_size;
    int item_size;
    int _lock;
} StaticQueue;

void queue_init(StaticQueue *queue, void *buf, int max_size, int item_size);
_Bool  queue_push(StaticQueue *queue, void *data);
_Bool  queue_pop(StaticQueue *queue, void *data);
void queue_empty(StaticQueue *queue);
_Bool  queue_isempty(StaticQueue *queue);
#line 5 "/home/mad/Tensile-Testing-Machine/Firmware/MaD_Firmware/src/Utility/Motion.c"
#line 1 "/home/mad/flexprop/include/propeller.h"
#line 13 "/home/mad/flexprop/include/propeller.h"
#line 1 "/home/mad/flexprop/include/cog.h"
#line 14 "/home/mad/flexprop/include/propeller.h"
#line 1 "/home/mad/flexprop/include/stdint.h"



typedef signed char int8_t;
typedef unsigned char uint8_t;

typedef signed short int16_t;
typedef unsigned short uint16_t;

typedef signed long int32_t;
typedef unsigned long uint32_t;

typedef long long int64_t;
typedef unsigned long long uint64_t;

typedef unsigned long uintptr_t;
typedef long intptr_t;

typedef int64_t intmax_t;
typedef uint64_t uintmax_t;

typedef int8_t int_least8_t;
typedef int16_t int_least16_t;
typedef int32_t int_least32_t;
typedef int64_t int_least64_t;

typedef uint8_t uint_least8_t;
typedef uint16_t uint_least16_t;
typedef uint32_t uint_least32_t;
typedef uint64_t uint_least64_t;

typedef int32_t int_fast8_t;
typedef int32_t int_fast16_t;
typedef int32_t int_fast32_t;
typedef int64_t int_fast64_t;

typedef uint32_t uint_fast8_t;
typedef uint32_t uint_fast16_t;
typedef uint32_t uint_fast32_t;
typedef uint64_t uint_fast64_t;
#line 15 "/home/mad/flexprop/include/propeller.h"
#line 22 "/home/mad/flexprop/include/propeller.h"
#line 1 "/home/mad/flexprop/include/propeller2.h"
#line 4 "/home/mad/flexprop/include/propeller2.h"
#line 1 "/home/mad/flexprop/include/stdint.h"
#line 5 "/home/mad/flexprop/include/propeller2.h"
#line 56 "/home/mad/flexprop/include/propeller2.h"
typedef struct _cartesian {
   int32_t x, y;
} cartesian_t;


typedef struct _polar {
   uint32_t r, t;
} polar_t;


typedef struct _counter64 {
    uint32_t low, high;
} counter64_t;
#line 96 "/home/mad/flexprop/include/propeller2.h"
void _clkset(uint32_t clkmode, uint32_t clkfreq);
void _hubset(uint32_t val);
void _reboot(void);


int _coginit(int cog, void *pgm, void *ptr);
#line 116 "/home/mad/flexprop/include/propeller2.h"
void _cogstop(int cog);
int _cogchk(int cog);
int _cogid(void);

int _locknew(void);
void _lockret(int lock);

int _locktry(int lock);
int _lockrel(int lock);
int _lockchk(int lock);

void _cogatn(uint32_t mask);
int _pollatn(void);
int _waitatn(void);


cartesian_t _rotxy(cartesian_t coord, uint32_t t);
cartesian_t _polxy(polar_t coord);
polar_t _xypol(cartesian_t coord);


uint32_t _rnd(void);


int _clz(uint32_t val);
int _encod(uint32_t val);
uint32_t _isqrt(uint32_t val);


uint32_t _cnt(void);
uint32_t _cnth(void);
counter64_t _cnthl();
uint32_t _getsec();
uint32_t _getms();
uint32_t _getus();

uint32_t _pollcnt(uint32_t tick);
void _waitcnt(uint32_t tick);

void _waitx(uint32_t cycles);
void _waitsec(uint32_t seconds);
void _waitms(uint32_t milliseconds);
void _waitus(uint32_t microseconds);


void _pinw(int pin, int val);
void _pinl(int pin);
void _pinh(int pin);
void _pinnot(int pin);
void _pinrnd(int pin);
void _pinf(int pin);
int _pinr(int pin);


void _wrpin(int pin, uint32_t val);
void _wxpin(int pin, uint32_t val);
void _wypin(int pin, uint32_t val);
void _akpin(int pin);
uint32_t _rdpin(int pin);
uint32_t _rqpin(int pin);


void _pinstart(int pin, uint32_t mode, uint32_t xval, uint32_t yval);

void _pinclear(int pin);


extern uint32_t _clockfreq(void);
extern uint32_t _clockmode(void);
#line 23 "/home/mad/flexprop/include/propeller.h"
#line 6 "/home/mad/Tensile-Testing-Machine/Firmware/MaD_Firmware/src/Utility/Motion.c"


static long motion_stack[ 30000 ];

static  _Bool  motion_enabled =  (0) ;
static long motion_setpoint_steps = 0;
long motion_position_steps = 0;
static long motion_feedrate_steps_per_second = 0;




static MotionCommand manual_buffer[ 100 ];
static MotionCommand test_buffer[ 10 ];

static StaticQueue manual_queue;
static StaticQueue test_queue;

static  _Bool  test_mode =  (0) ;

void motion_enable()
{
  motion_enabled =  (1) ;
}


void motion_disable()
{
  motion_enabled =  (0) ;
}

void motion_clear()
{
    queue_empty(&manual_queue);
}


_Bool  motion_add_move(int steps, int feedrate)
{
    if (!motion_enabled)
    {
        return  (0) ;
    }
    MotionCommand command;
    command.steps = steps;
    command.feedrate = feedrate;

    return queue_push(&manual_queue, &command);
}

void motion_test_start()
{
    test_mode =  (1) ;
}

void motion_test_end()
{
    test_mode =  (0) ;

}

void motion_test_clear()
{
    queue_empty(&test_queue);
}

_Bool  motion_test_is_empty()
{
    return queue_isempty(&test_queue);
}

_Bool  motion_test_is_full()
{
    return queue_isfull(&test_queue);
}

_Bool  motion_test_add_move(MotionCommand *command)
{

    return queue_push(&test_queue, (void*)command);
}

long motion_get_position()
{
    return motion_position_steps;
}

long motion_get_setpoint()
{
    return motion_setpoint_steps;
}

static void motion_cog(void *arg)
{
    test_mode =  (0) ;
    queue_init(&manual_queue, manual_buffer,  100 , sizeof(MotionCommand));
    queue_init(&test_queue, test_buffer,  10 , sizeof(MotionCommand));
    motion_enabled =  (1) ;
    while( (1) )
    {
        MotionCommand command;
        StaticQueue *queue = &manual_queue;
        if (test_mode)
        {
            queue = &test_queue;
        }
        if (queue_isempty(queue))
        {

            continue;
        }
        if (!queue_pop(queue, &command))
            continue;


        int delayus = 1000000 / command.feedrate;
        motion_setpoint_steps += command.steps;
        while (motion_position_steps != motion_setpoint_steps)
        {
            if (motion_enabled)
            {
                if (motion_setpoint_steps > motion_position_steps)
                {
                    _pinl( 12 );
                    motion_position_steps++;
                }
                else if (motion_setpoint_steps < motion_position_steps)
                {
                    _pinh( 12 );
                    motion_position_steps--;
                }
                _pinl( 13 );
                _waitus(delayus/2);
                _pinh( 13 );
                _waitus(delayus/2);
            }else
            {
                motion_setpoint_steps = motion_position_steps;
                queue_empty(&manual_queue);
                break;
            }
        }
    }
}

_Bool  motion_begin()
{
    int id =  __builtin_cogstart(motion_cog((0) ), &motion_stack[0]) ;
    if (id != -1)
    {
        return  (1) ;
    }
    return  (0) ;
}
