#line 1 "/home/mad/Tensile-Testing-Machine/Firmware/MaD_Firmware/src/Communication/Communication.c"
#line 1 "/home/mad/Tensile-Testing-Machine/Firmware/MaD_Firmware/include/Main/Communication/Communication.h"
#line 4 "/home/mad/Tensile-Testing-Machine/Firmware/MaD_Firmware/include/Main/Communication/Communication.h"
#line 1 "/home/mad/flexprop/include/stdbool.h"
#line 5 "/home/mad/Tensile-Testing-Machine/Firmware/MaD_Firmware/include/Main/Communication/Communication.h"
#line 1 "/home/mad/flexprop/include/stdint.h"



typedef signed char int8_t;
typedef unsigned char uint8_t;

typedef signed short int16_t;
typedef unsigned short uint16_t;

typedef signed long int32_t;
typedef unsigned long uint32_t;

typedef long long int64_t;
typedef unsigned long long uint64_t;

typedef unsigned long uintptr_t;
typedef long intptr_t;

typedef int64_t intmax_t;
typedef uint64_t uintmax_t;

typedef int8_t int_least8_t;
typedef int16_t int_least16_t;
typedef int32_t int_least32_t;
typedef int64_t int_least64_t;

typedef uint8_t uint_least8_t;
typedef uint16_t uint_least16_t;
typedef uint32_t uint_least32_t;
typedef uint64_t uint_least64_t;

typedef int32_t int_fast8_t;
typedef int32_t int_fast16_t;
typedef int32_t int_fast32_t;
typedef int64_t int_fast64_t;

typedef uint32_t uint_fast8_t;
typedef uint32_t uint_fast16_t;
typedef uint32_t uint_fast32_t;
typedef uint64_t uint_fast64_t;
#line 6 "/home/mad/Tensile-Testing-Machine/Firmware/MaD_Firmware/include/Main/Communication/Communication.h"
#line 1 "/home/mad/Tensile-Testing-Machine/Firmware/MaD_Firmware/lib/JSON/JSON.h"
#line 17 "/home/mad/Tensile-Testing-Machine/Firmware/MaD_Firmware/lib/JSON/JSON.h"
typedef struct MachineConfiguration
{
    char motorType[ 20 ];
    double maxMotorTorque;
    double maxMotorRPM;
    double gearDiameter;
    double gearPitch;
    double systemIntertia;
    double staticTorque;
    double load;
    char positionEncoderType[ 20 ];
    double positionEncoderStepsPerRev;
    char forceGauge[ 20 ];
    double forceGaugeScaleFactor;
    int forceGaugeZeroFactor;
} MachineConfiguration;

typedef struct MachinePerformance
{
    double minPosition;
    double maxPosition;
    double maxVelocity;
    double maxAcceleration;
    double maxForceTensile;
    double maxForceCompression;
    double forceGaugeNeutralOffset;
} MachinePerformance;

typedef struct MachineProfile
{
    char name[ 20 ];
    MachineConfiguration configuration;
    MachinePerformance performance;
} MachineProfile;

typedef struct SampleProfile
{
    char name[ 50 ];
    double length;
    double stretchMax;
    double maxVelocity;
    double maxAcceleration;
    double maxJerk;
    double maxForceTensile;
    double maxForceCompression;

} SampleProfile;
#line 7 "/home/mad/Tensile-Testing-Machine/Firmware/MaD_Firmware/include/Main/Communication/Communication.h"
#line 1 "/home/mad/Tensile-Testing-Machine/Firmware/MaD_Firmware/include/Utility/Monitor.h"
#line 1 "/home/mad/Tensile-Testing-Machine/Firmware/MaD_Firmware/lib/ForceGauge/ForceGauge.h"
#line 4 "/home/mad/Tensile-Testing-Machine/Firmware/MaD_Firmware/lib/ForceGauge/ForceGauge.h"
#line 1 "/home/mad/flexprop/include/stdlib.h"
#line 4 "/home/mad/flexprop/include/stdlib.h"
#line 1 "/home/mad/flexprop/include/compiler.h"
#line 5 "/home/mad/flexprop/include/stdlib.h"
#line 1 "/home/mad/flexprop/include/sys/size_t.h"





  typedef  unsigned long  size_t;
#line 6 "/home/mad/flexprop/include/stdlib.h"
#line 1 "/home/mad/flexprop/include/sys/wchar_t.h"
#line 15 "/home/mad/flexprop/include/sys/wchar_t.h"
typedef int wchar_t;
#line 24 "/home/mad/flexprop/include/sys/wchar_t.h"
typedef struct _Mbstate {
  unsigned int total:5;
  unsigned int left:5;
  unsigned int partial:22;
} _Mbstate_t;
#line 7 "/home/mad/flexprop/include/stdlib.h"
#line 1 "/home/mad/flexprop/include/sys/null.h"
#line 8 "/home/mad/flexprop/include/stdlib.h"
#line 22 "/home/mad/flexprop/include/stdlib.h"
    double atof(const char *);
    int atoi(const char *)  __fromfile("libc/stdlib/atoi.c") ;
    long atol(const char *)  __fromfile("libc/stdlib/atoi.c") ;
    long long atoll(const char *);

  long double strtold(const char *nptr, char **endptr);
  double strtod(const char *nptr, char **endptr);
  float strtof(const char *nptr, char **endptr);

    long strtol(const char *nptr, char **endptr, int base)  __fromfile("libc/stdlib/strtol.c") ;
    unsigned long strtoul(const char *nptr, char **endptr, int base)  __fromfile("libc/stdlib/strtoul.c") ;
  long long strtoll(const char *nptr, char **endptr, int base);
  unsigned long long strtoull(const char *nptr, char **endptr, int base);


    int rand(void)  __fromfile("libc/stdlib/rand.c") ;
    void srand(unsigned int seed)  __fromfile("libc/stdlib/rand.c") ;

    void *malloc(size_t n)  __fromfile("libc/stdlib/malloc.c") ;
    void *calloc(size_t, size_t)  __fromfile("libc/stdlib/malloc.c") ;
    void *realloc(void *, size_t)  __fromfile("libc/stdlib/malloc.c") ;
    void free(void *)  __fromfile("libc/stdlib/malloc.c") ;


    int atexit(void (*func)(void))  __fromfile("libc/stdlib/exit.c") ;
     void exit(int status)  __fromfile("libc/stdlib/exit.c") ;
     void abort(void)  __fromfile("libc/stdlib/abort.c") ;
     void _Exit(int status)  __fromfile("libc/stdlib/_Exit.c") ;
   void _exit(int status);
#line 56 "/home/mad/flexprop/include/stdlib.h"
   long labs(long l);


   long long llabs(long long ll);


  typedef struct {
    int quot, rem;
  } div_t;

  typedef struct {
    long int quot, rem;
  } ldiv_t;

  typedef struct {
    long long quot, rem;
  } lldiv_t;

  div_t div(int num, int denom);
  ldiv_t ldiv(long num, long denom);
  lldiv_t lldiv(long long num, long long denom);

    void qsort(void *base, size_t nmemb, size_t size, int (*compare)(const void *, const void *))  __fromfile("libc/stdlib/qsort.c") ;
  void *bsearch(const void *key, const void *base, size_t nmemb, size_t size,
		int (*compare)(const void *, const void *));

    char *getenv(const char *name)  __fromfile("libc/stdlib/getenv.c") ;
    int putenv(const char *name)  __fromfile("libc/stdlib/putenv.c") ;


  extern int _mb_cur_max;



  int mblen(const char *s, size_t n);
  int mbtowc(wchar_t * __restrict pwc, const char * __restrict s, size_t n);
  size_t mbstowcs(wchar_t *dest, const char *src, size_t n);


  int system(const char *command);
#line 102 "/home/mad/flexprop/include/stdlib.h"
    int _itoa_prec( unsigned int x, char *buf, unsigned base, int prec );
    int _lltoa_prec( unsigned long long x, char *buf, unsigned base, int prec );
#line 5 "/home/mad/Tensile-Testing-Machine/Firmware/MaD_Firmware/lib/ForceGauge/ForceGauge.h"
#line 1 "/home/mad/Tensile-Testing-Machine/Firmware/MaD_Firmware/lib/JSON/JSON.h"
#line 17 "/home/mad/Tensile-Testing-Machine/Firmware/MaD_Firmware/lib/JSON/JSON.h"
typedef struct MachineConfiguration
{
    char motorType[ 20 ];
    double maxMotorTorque;
    double maxMotorRPM;
    double gearDiameter;
    double gearPitch;
    double systemIntertia;
    double staticTorque;
    double load;
    char positionEncoderType[ 20 ];
    double positionEncoderStepsPerRev;
    char forceGauge[ 20 ];
    double forceGaugeScaleFactor;
    int forceGaugeZeroFactor;
} MachineConfiguration;

typedef struct MachinePerformance
{
    double minPosition;
    double maxPosition;
    double maxVelocity;
    double maxAcceleration;
    double maxForceTensile;
    double maxForceCompression;
    double forceGaugeNeutralOffset;
} MachinePerformance;

typedef struct MachineProfile
{
    char name[ 20 ];
    MachineConfiguration configuration;
    MachinePerformance performance;
} MachineProfile;

typedef struct SampleProfile
{
    char name[ 50 ];
    double length;
    double stretchMax;
    double maxVelocity;
    double maxAcceleration;
    double maxJerk;
    double maxForceTensile;
    double maxForceCompression;

} SampleProfile;
#line 6 "/home/mad/Tensile-Testing-Machine/Firmware/MaD_Firmware/lib/ForceGauge/ForceGauge.h"
#line 1 "/home/mad/flexprop/include/stdbool.h"
#line 7 "/home/mad/Tensile-Testing-Machine/Firmware/MaD_Firmware/lib/ForceGauge/ForceGauge.h"
#line 1 "/home/mad/flexprop/include/stdint.h"
#line 8 "/home/mad/Tensile-Testing-Machine/Firmware/MaD_Firmware/lib/ForceGauge/ForceGauge.h"






typedef struct __using("lib/Protocol/jm_fullduplexserial.spin2") FDS;

typedef struct ForceGauge_s
{
    int counter;
    unsigned int force;
    uint8_t buffer[4];
    FDS serial;
    int rx, tx;
    int forceRaw;
    _Bool  responding;
    int cogid;
} ForceGauge;

int force_gauge_raw_to_force(int zero, double slope, int raw);
int raw_to_force(int raw, MachineConfiguration *configuration);

_Bool  force_gauge_begin(ForceGauge *forceGauge, int rx, int tx);
void force_gauge_stop(ForceGauge *forceGauge);
#line 2 "/home/mad/Tensile-Testing-Machine/Firmware/MaD_Firmware/include/Utility/Monitor.h"
#line 1 "/home/mad/Tensile-Testing-Machine/Firmware/MaD_Firmware/include/StateMachine.h"
#line 3 "/home/mad/Tensile-Testing-Machine/Firmware/MaD_Firmware/include/StateMachine.h"
#line 1 "/home/mad/flexprop/include/stdbool.h"
#line 4 "/home/mad/Tensile-Testing-Machine/Firmware/MaD_Firmware/include/StateMachine.h"
#line 1 "/home/mad/Tensile-Testing-Machine/Firmware/MaD_Firmware/include/StateMachineDefinition.h"
#line 1 "/home/mad/flexprop/include/stdbool.h"
#line 2 "/home/mad/Tensile-Testing-Machine/Firmware/MaD_Firmware/include/StateMachineDefinition.h"

typedef enum State
{
    STATE_SELFCHECK,
    STATE_MACHINECHECK,
    STATE_MOTION
} State;

typedef enum MotionStatus
{
    MOTIONSTATUS_DISABLED,
    MOTIONSTATUS_ENABLED,
    MOTIONSTATUS_SAMPLE_LIMIT,
    MOTIONSTATUS_MACHINE_LIMIT,
    MOTIONSTATUS_FAULTED
} MotionStatus;

typedef enum MotionOverTravel
{
    MOTION_LIMIT_OK,
    MOTION_LIMIT_UPPER,
    MOTION_LIMIT_LOWER
} MotionOverTravel;
#line 30 "/home/mad/Tensile-Testing-Machine/Firmware/MaD_Firmware/include/StateMachineDefinition.h"
typedef enum MotionCondition
{
    CONDITION_LENGTH,
    CONDITION_FORCE,
    CONDITION_TENSION,
    CONDITION_COMPRESSION,
    CONDITION_UPPER,
    CONDITION_LOWER,
    CONDITION_DOOR,
    CONDITION_STOPPED,
    CONDITION_MOVING,
} MotionCondition;

typedef enum MotionMode
{
    MODE_MANUAL,
    MODE_TEST,
    MODE_TEST_RUNNING
} MotionMode;

typedef enum ModeFunctions
{
    FUNC_MANUAL_OFF,
    FUNC_MANUAL_INCREMENTAL_JOG,
    FUNC_MANUAL_CONTINUOUS_JOG,
    FUNC_MANUAL_POSITIONAL_MOVE,
    FUNC_MANUAL_HOME,
    FUNC_MANUAL_MOVE_GAUGE_LENGTH,
    FUNC_MANUAL_MOVE_FORCE,
    FUNC_TEST_LOAD,
    FUNC_TEST_RUN,
    FUNC_TEST_STOP,
    FUNC_TEST_TOGGLE_HOLD_RESUME
} ModeFunctions;

typedef struct SelfCheckParameters
{
    _Bool  chargePump;
} SelfCheckParameters;

typedef struct MachineCheckParameters
{
    _Bool  switchedPower;
    MotionOverTravel esdTravelLimit;
    _Bool  esdSwitch;
    _Bool  servoOK;
    _Bool  forceGaugeCom;
    _Bool  servoCom;
    _Bool  rtcCom;

} MachineCheckParameters;

typedef struct MotionParameters
{
    MotionStatus status;
    MotionCondition condition;
    MotionMode mode;
} MotionParameters;


typedef struct MachineState
{
    State state;
    SelfCheckParameters selfCheckParameters;
    MachineCheckParameters machineCheckParameters;
    MotionParameters motionParameters;
    ModeFunctions _function;
    int _functionData;
    int _lock;
} MachineState;

typedef enum Parameter
{
    PARAM_SELF_CHARGE_PUMP,
    PARAM_MACHINE_SWITCHED_POWER,
    PARAM_MACHINE_ESD_TRAVEL_LIMIT,
    PARAM_MACHINE_ESD_SWITCH,
    PARAM_MACHINE_SERVO_OK,
    PARAM_MACHINE_FORCE_GAUGE_COM,
    PARAM_MACHINE_SERVO_COM,
    PARAM_MACHINE_RTC_COM,
    PARAM_MOTION_STATUS,
    PARAM_MOTION_CONDITION,
    PARAM_MOTION_MODE,
    PARAM_FUNCTION
} Parameter;
#line 5 "/home/mad/Tensile-Testing-Machine/Firmware/MaD_Firmware/include/StateMachine.h"

MachineState *machine_state_create();


void machine_state_init(MachineState *machineState);
void state_machine_set(MachineState *machineState, Parameter param, int state);
_Bool  state_machine_self_check_equal(SelfCheckParameters *selfCheckParameters1, SelfCheckParameters *selfCheckParameters2);
_Bool  state_machine_check_equal(MachineCheckParameters *motionParameters1, MachineCheckParameters *motionParameters2);
_Bool  state_machine_motion_equal(MotionParameters *motionParameters1, MotionParameters *motionParameters2);
_Bool  state_machine_equal(MachineState *machineState1, MachineState *machineState2);
#line 3 "/home/mad/Tensile-Testing-Machine/Firmware/MaD_Firmware/include/Utility/Monitor.h"
#line 1 "/home/mad/Tensile-Testing-Machine/Firmware/MaD_Firmware/lib/Encoder/Encoder.h"


typedef struct __using("lib/Encoder/jm_quadrature.spin2") Encoder;
#line 4 "/home/mad/Tensile-Testing-Machine/Firmware/MaD_Firmware/include/Utility/Monitor.h"
#line 1 "/home/mad/flexprop/include/stdint.h"
#line 5 "/home/mad/Tensile-Testing-Machine/Firmware/MaD_Firmware/include/Utility/Monitor.h"
typedef struct MonitorData
{
    int forceRaw;
    int encoderRaw;
    int forcemN;
    int encoderum;
    double force;
    double position;
    int setpoint;
    unsigned int timems;
    unsigned int timeus;
    int log;
} MonitorData;


typedef struct MonitorDataPacket
{
    int forcemN;
    int encoderum;
    int setpointum;
    unsigned int timeus;
    int log;
} MonitorDataPacket;

typedef struct Monitor
{
    MonitorData data;
    MachineState *machineState;
    MachineConfiguration *configuration;
    int sampleRate;
    int cogid;

    MonitorData cache;
    int cacheLock;
} Monitor;
void monitor_sync_setpoint();
void monitor_set_address(int addr);
MonitorData *monitor_read_data();
_Bool  monitor_begin(Monitor *monitor, MachineState *machineState, MachineConfiguration *configuration, int sampleRate);


_Bool  read_sd_profile(MachineProfile * profile);
int read_sd_card_data(MonitorData *data, int index, int count);
int read_data_size();
_Bool  write_sd_profile(MachineProfile * profile);
#line 8 "/home/mad/Tensile-Testing-Machine/Firmware/MaD_Firmware/include/Main/Communication/Communication.h"
#line 1 "/home/mad/Tensile-Testing-Machine/Firmware/MaD_Firmware/include/Utility/ControlSystem.h"
#line 3 "/home/mad/Tensile-Testing-Machine/Firmware/MaD_Firmware/include/Utility/ControlSystem.h"
#line 1 "/home/mad/Tensile-Testing-Machine/Firmware/MaD_Firmware/lib/JSON/JSON.h"
#line 17 "/home/mad/Tensile-Testing-Machine/Firmware/MaD_Firmware/lib/JSON/JSON.h"
typedef struct MachineConfiguration
{
    char motorType[ 20 ];
    double maxMotorTorque;
    double maxMotorRPM;
    double gearDiameter;
    double gearPitch;
    double systemIntertia;
    double staticTorque;
    double load;
    char positionEncoderType[ 20 ];
    double positionEncoderStepsPerRev;
    char forceGauge[ 20 ];
    double forceGaugeScaleFactor;
    int forceGaugeZeroFactor;
} MachineConfiguration;

typedef struct MachinePerformance
{
    double minPosition;
    double maxPosition;
    double maxVelocity;
    double maxAcceleration;
    double maxForceTensile;
    double maxForceCompression;
    double forceGaugeNeutralOffset;
} MachinePerformance;

typedef struct MachineProfile
{
    char name[ 20 ];
    MachineConfiguration configuration;
    MachinePerformance performance;
} MachineProfile;

typedef struct SampleProfile
{
    char name[ 50 ];
    double length;
    double stretchMax;
    double maxVelocity;
    double maxAcceleration;
    double maxJerk;
    double maxForceTensile;
    double maxForceCompression;

} SampleProfile;
#line 4 "/home/mad/Tensile-Testing-Machine/Firmware/MaD_Firmware/include/Utility/ControlSystem.h"
#line 1 "/home/mad/Tensile-Testing-Machine/Firmware/MaD_Firmware/include/Monitor.h"
#line 1 "/home/mad/Tensile-Testing-Machine/Firmware/MaD_Firmware/lib/ForceGauge/ForceGauge.h"
#line 2 "/home/mad/Tensile-Testing-Machine/Firmware/MaD_Firmware/include/Monitor.h"
#line 1 "/home/mad/Tensile-Testing-Machine/Firmware/MaD_Firmware/include/StateMachine.h"
#line 3 "/home/mad/Tensile-Testing-Machine/Firmware/MaD_Firmware/include/Monitor.h"
#line 1 "/home/mad/Tensile-Testing-Machine/Firmware/MaD_Firmware/lib/Encoder/Encoder.h"
#line 4 "/home/mad/Tensile-Testing-Machine/Firmware/MaD_Firmware/include/Monitor.h"
#line 1 "/home/mad/flexprop/include/stdint.h"
#line 5 "/home/mad/Tensile-Testing-Machine/Firmware/MaD_Firmware/include/Monitor.h"
typedef struct MonitorData
{
    int forceRaw;
    int encoderRaw;
    int forcemN;
    int encoderum;
    double force;
    double position;
    int setpoint;
    unsigned int timems;
    unsigned int timeus;
    int log;
} MonitorData;


typedef struct MonitorDataPacket
{
    int forcemN;
    int encoderum;
    int setpointum;
    unsigned int timeus;
    int log;
} MonitorDataPacket;

typedef struct Monitor
{
    MonitorData data;
    MachineState *machineState;
    MachineConfiguration *configuration;
    int sampleRate;
    int cogid;

    MonitorData cache;
    int cacheLock;
} Monitor;
void monitor_sync_setpoint();
void monitor_set_address(int addr);
MonitorData *monitor_read_data();
_Bool  monitor_begin(Monitor *monitor, MachineState *machineState, MachineConfiguration *configuration, int sampleRate);


_Bool  read_sd_profile(MachineProfile * profile);
int read_sd_card_data(MonitorData *data, int index, int count);
int read_data_size();
_Bool  write_sd_profile(MachineProfile * profile);
#line 5 "/home/mad/Tensile-Testing-Machine/Firmware/MaD_Firmware/include/Utility/ControlSystem.h"
#line 1 "/home/mad/Tensile-Testing-Machine/Firmware/MaD_Firmware/lib/NavKey/i2cNavKey.h"
#line 19 "/home/mad/Tensile-Testing-Machine/Firmware/MaD_Firmware/lib/NavKey/i2cNavKey.h"
#line 1 "/home/mad/flexprop/include/stdbool.h"
#line 20 "/home/mad/Tensile-Testing-Machine/Firmware/MaD_Firmware/lib/NavKey/i2cNavKey.h"
#line 1 "/home/mad/flexprop/include/stdint.h"
#line 21 "/home/mad/Tensile-Testing-Machine/Firmware/MaD_Firmware/lib/NavKey/i2cNavKey.h"
#line 1 "/home/mad/flexprop/include/stdlib.h"
#line 22 "/home/mad/Tensile-Testing-Machine/Firmware/MaD_Firmware/lib/NavKey/i2cNavKey.h"

typedef struct __using("lib/Protocol/jm_i2c.spin2") Bus;


enum GCONF_PARAMETER
{
	FLOAT_DATA = 0x01,
	INT_DATA = 0x00,
	WRAP_ENABLE = 0x02,
	WRAP_DISABLE = 0x00,
	DIRE_LEFT = 0x04,
	DIRE_RIGHT = 0x00,
	IPUP_DISABLE = 0x08,
	IPUP_ENABLE = 0x00,
	CLK_STRECH_ENABLE = 0x10,
	CLK_STRECH_DISABLE = 0x00,
	EEPROM_BANK1 = 0x20,
	EEPROM_BANK2 = 0x00,
	RESET = 0x80,
};

union Data_v
{
	float fval;
	uint16_t wval;
	int32_t val;
	uint8_t bval[4];
};
typedef struct navkeystatus_t
{
	int UPR, UPP, DNR, DNP, RTR, RTP, LTR, LTP;
	int CTRR, CTRP, CTRDP;
	int RINC, RDEC, RMAX, RMIN;
	int GP1POS, GP1NEG, GP2POS, GP2NEG, GP3POS, GP3NEG;
	int FADEINT;
} NavKeyStatus;

typedef struct navkey_t
{
	Bus i2cBus;
	int scl;
	int sda;
	NavKeyStatus status;
	uint8_t _add;
	uint16_t _stat;
	uint8_t _stat2;
	uint8_t _statfade;
	uint8_t _gconf;
	union Data_v _tem_data;
} NavKey;

void navkey_begin(NavKey *navkey, int scl, int sda, uint8_t addr, uint8_t conf);
void navkey_reset(NavKey *navkey);
void navkey_auto_config_interrupt(NavKey *navkey);


void navkey_update_status(NavKey *navkey);

uint8_t navkey_read_gp1_conf(NavKey *navkey);
uint8_t navkey_read_gp2_conf(NavKey *navkey);
uint8_t navkey_read_gp3_conf(NavKey *navkey);
uint16_t navkey_read_interrupt_config(NavKey *navkey);


uint16_t navkey_read_status(NavKey *navkey);

uint8_t navkey_read_int2(NavKey *navkey);

uint8_t navkey_read_fade_status(NavKey *navkey);


float navkey_read_counter_float(NavKey *navkey);
int32_t navkey_read_counter_long(NavKey *navkey);
int16_t navkey_read_counter_int(NavKey *navkey);
int8_t navkey_read_counter_byte(NavKey *navkey);

int32_t navkey_read_max(NavKey *navkey);
float navkey_read_max_float(NavKey *navkey);

int32_t navkey_read_min(NavKey *navkey);
float navkey_read_min_float(NavKey *navkey);

int32_t navkey_readStep(NavKey *navkey);
float navkey_read_step_float(NavKey *navkey);


uint8_t navkey_read_gp1(NavKey *navkey);
uint8_t navkey_read_gp2(NavKey *navkey);
uint8_t navkey_read_gp3(NavKey *navkey);


uint8_t navkey_read_double_push_period(NavKey *navkey);
uint8_t navkey_read_fade_gp(NavKey *navkey);


uint8_t navkey_read_eeprom(NavKey *navkey, uint8_t add);


uint8_t navkey_read_id_code(NavKey *navkey);
uint8_t navkey_read_version(NavKey *navkey);


void navkey_write_gp1_conf(NavKey *navkey, uint8_t gp1);
void navkey_write_gp2_conf(NavKey *navkey, uint8_t gp2);
void navkey_write_gp3_conf(NavKey *navkey, uint8_t gp3);
void navkey_write_interrupt_config(NavKey *navkey, uint16_t interrupt);


void navkey_write_counter(NavKey *navkey, int counter);

void navkey_write_max(NavKey *navkey, int max);

void navkey_write_min(NavKey *navkey, int min);

void navkey_write_step(NavKey *navkey, int step);


void navkey_write_gp1(NavKey *navkey, uint8_t gp1);
void navkey_write_gp2(NavKey *navkey, uint8_t gp2);
void navkey_write_gp3(NavKey *navkey, uint8_t gp3);


void navkey_write_double_push_period(NavKey *navkey, uint8_t dperiod);
void navkey_write_fade_gp(NavKey *navkey, uint8_t fade);

void navkey_write_gamma_gp1(NavKey *navkey, uint8_t gamma);
void navkey_write_gamma_gp2(NavKey *navkey, uint8_t gamma);
void navkey_write_gamma_gp3(NavKey *navkey, uint8_t gamma);


void navkey_writeEEPROM(NavKey *navkey, uint8_t add, uint8_t data);

void navkey_write8(NavKey *navkey, uint8_t reg, uint8_t data);
void navkey_write16(NavKey *navkey, uint8_t reg, uint16_t data);
void navkey_write32(NavKey *navkey, uint8_t reg, int32_t data);
void navkey_write_float(NavKey *navkey, uint8_t reg, float data);
void navkey_write24(NavKey *navkey, uint8_t reg, uint32_t data);
#line 6 "/home/mad/Tensile-Testing-Machine/Firmware/MaD_Firmware/include/Utility/ControlSystem.h"
#line 1 "/home/mad/Tensile-Testing-Machine/Firmware/MaD_Firmware/include/StateMachine.h"
#line 7 "/home/mad/Tensile-Testing-Machine/Firmware/MaD_Firmware/include/Utility/ControlSystem.h"
#line 1 "/home/mad/Tensile-Testing-Machine/Firmware/MaD_Firmware/include/IOBoard.h"
#line 8 "/home/mad/Tensile-Testing-Machine/Firmware/MaD_Firmware/include/Utility/ControlSystem.h"

typedef enum homingstate_e
{
    HOMING_NONE,
    HOMING_COMPLETE,
    HOMING_SEEKING,
    HOMING_BACKING_OFF,
    HOMING_SEEKING_SLOW
} HomingState;

typedef struct control_t
{
    MachineProfile *machineProfile;
    MonitorData *monitorData;
    MachineState *stateMachine;
    int cogid;
} ControlSystem;

_Bool  control_begin(ControlSystem *control, MachineProfile *machineProfile, MachineState *stateMachine, MonitorData *monitorData);
#line 9 "/home/mad/Tensile-Testing-Machine/Firmware/MaD_Firmware/include/Main/Communication/Communication.h"
#line 1 "/home/mad/Tensile-Testing-Machine/Firmware/MaD_Firmware/include/CommunicationDefinition.h"
#line 10 "/home/mad/Tensile-Testing-Machine/Firmware/MaD_Firmware/include/Main/Communication/Communication.h"

void beginCommunication(MachineProfile *machineProfile, MachineState *machineState, Monitor *monitor, ControlSystem *control);
#line 2 "/home/mad/Tensile-Testing-Machine/Firmware/MaD_Firmware/src/Communication/Communication.c"
#line 1 "/home/mad/Tensile-Testing-Machine/Firmware/MaD_Firmware/include/Utility/StateMachine.h"
#line 3 "/home/mad/Tensile-Testing-Machine/Firmware/MaD_Firmware/src/Communication/Communication.c"
#line 1 "/home/mad/Tensile-Testing-Machine/Firmware/MaD_Firmware/include/Utility/Error.h"
#line 23 "/home/mad/Tensile-Testing-Machine/Firmware/MaD_Firmware/include/Utility/Error.h"
typedef enum Error_e
{
    SUCCESS,
    FAIL,

    DISPLAY_NOT_FOUND = 2,
    DISPLAY_PLL_FAIL,
    DISPLAY_SDRAM_FAIL,

    RTC_RESET = 51,
    RTC_NOT_FOUND,

    DYN4_NOT_RESPONDING = 101,
    DYN4_CONNECTION_LOST,
    DYN4_COG_FAIL,

    FORCEGAUGE_NOT_RESPONDING = 151,
    FORCEGAUGE_CONNECTION_LOST,
    FORCEGAUGE_COG_FAIL,

    JSON_FILE_ERROR = 201,
    JSON_FILE_NOT_FOUND,
    JSON_FILE_READ_FAIL,
    JSON_FILE_WRITE_FAIL,
    JSON_FILE_INVALID,
    JSON_FILE_EMPTY,
    JSON_FILE_NOT_VALID,

    MCP23017_NOT_FOUND = 251,

    W25QXX_NOT_FOUND = 301,
    W25QXX_NOT_AVAILABLE,
    W25QXX_INVALID_ID,

    SEM_NOT_AVAILABLE = 351
} Error;

void print_error(Error value);
void seterror(Error *err, Error value);
#line 4 "/home/mad/Tensile-Testing-Machine/Firmware/MaD_Firmware/src/Communication/Communication.c"
#line 1 "/home/mad/Tensile-Testing-Machine/Firmware/MaD_Firmware/include/Utility/Motion.h"
#line 1 "/home/mad/flexprop/include/stdbool.h"
#line 2 "/home/mad/Tensile-Testing-Machine/Firmware/MaD_Firmware/include/Utility/Motion.h"
typedef struct MotionCommand{
    int steps;
    int feedrate;
    _Bool  last;
} MotionCommand;

void motion_enable();
void motion_disable();
void motion_clear();
_Bool  motion_add_move(int steps, int feedrate);
void motion_test_start();
void motion_test_end();
void motion_test_clear();
_Bool  motion_test_is_empty();
_Bool  motion_test_add_move(MotionCommand *command);
long motion_get_position();
long motion_get_setpoint();
#line 5 "/home/mad/Tensile-Testing-Machine/Firmware/MaD_Firmware/src/Communication/Communication.c"
#line 1 "/home/mad/Tensile-Testing-Machine/Firmware/MaD_Firmware/include/Utility/Monitor.h"
#line 1 "/home/mad/Tensile-Testing-Machine/Firmware/MaD_Firmware/lib/ForceGauge/ForceGauge.h"
#line 2 "/home/mad/Tensile-Testing-Machine/Firmware/MaD_Firmware/include/Utility/Monitor.h"
#line 1 "/home/mad/Tensile-Testing-Machine/Firmware/MaD_Firmware/include/StateMachine.h"
#line 3 "/home/mad/Tensile-Testing-Machine/Firmware/MaD_Firmware/include/Utility/Monitor.h"
#line 1 "/home/mad/Tensile-Testing-Machine/Firmware/MaD_Firmware/lib/Encoder/Encoder.h"
#line 4 "/home/mad/Tensile-Testing-Machine/Firmware/MaD_Firmware/include/Utility/Monitor.h"
#line 1 "/home/mad/flexprop/include/stdint.h"
#line 5 "/home/mad/Tensile-Testing-Machine/Firmware/MaD_Firmware/include/Utility/Monitor.h"
typedef struct MonitorData
{
    int forceRaw;
    int encoderRaw;
    int forcemN;
    int encoderum;
    double force;
    double position;
    int setpoint;
    unsigned int timems;
    unsigned int timeus;
    int log;
} MonitorData;


typedef struct MonitorDataPacket
{
    int forcemN;
    int encoderum;
    int setpointum;
    unsigned int timeus;
    int log;
} MonitorDataPacket;

typedef struct Monitor
{
    MonitorData data;
    MachineState *machineState;
    MachineConfiguration *configuration;
    int sampleRate;
    int cogid;

    MonitorData cache;
    int cacheLock;
} Monitor;
void monitor_sync_setpoint();
void monitor_set_address(int addr);
MonitorData *monitor_read_data();
_Bool  monitor_begin(Monitor *monitor, MachineState *machineState, MachineConfiguration *configuration, int sampleRate);


_Bool  read_sd_profile(MachineProfile * profile);
int read_sd_card_data(MonitorData *data, int index, int count);
int read_data_size();
_Bool  write_sd_profile(MachineProfile * profile);
#line 6 "/home/mad/Tensile-Testing-Machine/Firmware/MaD_Firmware/src/Communication/Communication.c"
#line 1 "/home/mad/flexprop/include/stdlib.h"
#line 7 "/home/mad/Tensile-Testing-Machine/Firmware/MaD_Firmware/src/Communication/Communication.c"
#line 1 "/home/mad/Tensile-Testing-Machine/Firmware/MaD_Firmware/lib/Queue/StaticQueue.h"
#line 1 "/home/mad/flexprop/include/stdbool.h"
#line 2 "/home/mad/Tensile-Testing-Machine/Firmware/MaD_Firmware/lib/Queue/StaticQueue.h"
#line 1 "/home/mad/flexprop/include/stdlib.h"
#line 3 "/home/mad/Tensile-Testing-Machine/Firmware/MaD_Firmware/lib/Queue/StaticQueue.h"
typedef struct StaticQueue_t {
    void *buf;
    int front;
    int rear;
    int size;
    int max_size;
    int item_size;
    int _lock;
} StaticQueue;

void queue_init(StaticQueue *queue, void *buf, int max_size, int item_size);
_Bool  queue_push(StaticQueue *queue, void *data);
_Bool  queue_pop(StaticQueue *queue, void *data);
void queue_empty(StaticQueue *queue);
_Bool  queue_isempty(StaticQueue *queue);
#line 8 "/home/mad/Tensile-Testing-Machine/Firmware/MaD_Firmware/src/Communication/Communication.c"
#line 1 "/home/mad/flexprop/include/propeller.h"
#line 13 "/home/mad/flexprop/include/propeller.h"
#line 1 "/home/mad/flexprop/include/cog.h"
#line 14 "/home/mad/flexprop/include/propeller.h"
#line 1 "/home/mad/flexprop/include/stdint.h"
#line 15 "/home/mad/flexprop/include/propeller.h"
#line 22 "/home/mad/flexprop/include/propeller.h"
#line 1 "/home/mad/flexprop/include/propeller2.h"
#line 4 "/home/mad/flexprop/include/propeller2.h"
#line 1 "/home/mad/flexprop/include/stdint.h"
#line 5 "/home/mad/flexprop/include/propeller2.h"
#line 56 "/home/mad/flexprop/include/propeller2.h"
typedef struct _cartesian {
   int32_t x, y;
} cartesian_t;


typedef struct _polar {
   uint32_t r, t;
} polar_t;


typedef struct _counter64 {
    uint32_t low, high;
} counter64_t;
#line 96 "/home/mad/flexprop/include/propeller2.h"
void _clkset(uint32_t clkmode, uint32_t clkfreq);
void _hubset(uint32_t val);
void _reboot(void);


int _coginit(int cog, void *pgm, void *ptr);
#line 116 "/home/mad/flexprop/include/propeller2.h"
void _cogstop(int cog);
int _cogchk(int cog);
int _cogid(void);

int _locknew(void);
void _lockret(int lock);

int _locktry(int lock);
int _lockrel(int lock);
int _lockchk(int lock);

void _cogatn(uint32_t mask);
int _pollatn(void);
int _waitatn(void);


cartesian_t _rotxy(cartesian_t coord, uint32_t t);
cartesian_t _polxy(polar_t coord);
polar_t _xypol(cartesian_t coord);


uint32_t _rnd(void);


int _clz(uint32_t val);
int _encod(uint32_t val);
uint32_t _isqrt(uint32_t val);


uint32_t _cnt(void);
uint32_t _cnth(void);
counter64_t _cnthl();
uint32_t _getsec();
uint32_t _getms();
uint32_t _getus();

uint32_t _pollcnt(uint32_t tick);
void _waitcnt(uint32_t tick);

void _waitx(uint32_t cycles);
void _waitsec(uint32_t seconds);
void _waitms(uint32_t milliseconds);
void _waitus(uint32_t microseconds);


void _pinw(int pin, int val);
void _pinl(int pin);
void _pinh(int pin);
void _pinnot(int pin);
void _pinrnd(int pin);
void _pinf(int pin);
int _pinr(int pin);


void _wrpin(int pin, uint32_t val);
void _wxpin(int pin, uint32_t val);
void _wypin(int pin, uint32_t val);
void _akpin(int pin);
uint32_t _rdpin(int pin);
uint32_t _rqpin(int pin);


void _pinstart(int pin, uint32_t mode, uint32_t xval, uint32_t yval);

void _pinclear(int pin);


extern uint32_t _clockfreq(void);
extern uint32_t _clockmode(void);
#line 23 "/home/mad/flexprop/include/propeller.h"
#line 9 "/home/mad/Tensile-Testing-Machine/Firmware/MaD_Firmware/src/Communication/Communication.c"
#line 17 "/home/mad/Tensile-Testing-Machine/Firmware/MaD_Firmware/src/Communication/Communication.c"
static long comm_stack[ 3000 ];
typedef struct __using("lib/Protocol/jm_fullduplexserial.spin2") FDS;

static FDS fds;


static  _Bool  receive(char *buf, unsigned int size)
{
    if (buf ==  (0) )
    {
        return  (0) ;
    }
    for (unsigned int i = 0; i < size; i++)
    {
        buf[i] = fds.rxtime(10);
        if (buf[i] == -1)
        {
            ;
            return  (0) ;
        }
    }
    return  (1) ;
}

static  _Bool  send(int cmd, char *buf, uint16_t size)
{
    ;

    char *bufCopy =  (0) ;
    if (size != 0)
    {
        bufCopy = (char *)__builtin_alloca(size);
        memcpy(bufCopy, buf, size);
        if (bufCopy ==  (0) )
        {
            ;
            return  (0) ;
        }
    }
    fds.tx(0x55);
    fds.tx(cmd);
    fds.tx(size);
    fds.tx(size>>8);

    for (unsigned int i = 0; i < size; i++)
    {
        fds.tx(bufCopy[i]);
    }
    unsigned crc = crc8(bufCopy, size);
    fds.tx(crc);
    return  (1) ;
}

static int recieveCMD(Monitor *monitor)
{
    while (1)
    {
        while (fds.rxcheck() != 0x55)
        {
        }
        int cmd = fds.rxtime(10);
        if (cmd != -1)
        {
            return cmd;
        }
    }
}

typedef struct communicationData
{
    MachineProfile *machineProfile;
    MachineState *machineState;
    Monitor *monitor;
    ControlSystem *control;
} CommunicationData;

static void load_machine_profile(MachineProfile *profile)
{

  if (!read_sd_profile(profile))
  {

    return;
  }

}

void beginCommunication(CommunicationData * arg)
{
    MachineProfile *machineProfile = arg->machineProfile;
    MachineState *machineState = arg->machineState;
    Monitor *monitor = arg->monitor;
    ControlSystem *control = arg->control;
    load_machine_profile(machineProfile);

    fds.start(57, 56, 0, 1000000);
    while (1)
    {
        ;
        int cmd = recieveCMD(monitor);
        ;
        if ((cmd &  128 ) !=  128 )
        {
            ;
            switch (cmd)
            {
            case  0 :
            {
                ;
                uint8_t res =  1 ;
                send( 0 , (char *)&res, 1);
                break;
            }
            case  11 :
            {
                ;
                uint8_t awk = 0;
                send( 11 , (char *)&awk, 1);
                break;
            }
            case  1 :
            {
                ;
                MonitorDataPacket packet;
                packet.forcemN = monitor->data.forcemN;
                packet.encoderum = monitor->data.encoderum;
                packet.setpointum = monitor->data.setpoint;
                packet.timeus = monitor->data.timeus;
                packet.log = monitor->data.log;

                send( 1 , (char *)&packet, sizeof(MonitorDataPacket));

                break;
            }
            case  2 :
            {
                ;
                send( 2 , (char *)machineState, sizeof(MachineState));
                break;
            }
            case  3 :
            {
                ;
                send( 3 , (char *)machineProfile, sizeof(MachineProfile));
                break;
            }
            case  4 :
            {
                ;
                send( 4 , (char *)&(machineProfile->configuration), sizeof(MachineConfiguration));
                break;
            }
            case  5 :
            {
                ;
                send( 5 , (char *)&(machineProfile->performance), sizeof(MachinePerformance));
                break;
            }
            case  7 :
            {
                ;
                send( 7 , (char *)&(machineState->motionParameters.mode), sizeof(MotionMode));
                break;
            }
            case  8 :
            {
                ;
                send( 8 , (char *)&(machineState->_function), sizeof(int));
                send( 8 , (char *)&(machineState->_functionData), sizeof(int));
                break;
            }
            case  9 :
            {
                ;
                send( 9 , (char *)&(machineState->motionParameters.status), sizeof(int));
                break;
            }
            case  12 :
            {
                ;
                uint32_t index;
                uint8_t count;
                if (receive((char *)&index, sizeof(uint32_t)) && receive((char *)&count, sizeof(uint32_t)))
                {
                    MonitorData buffer[255];

                    if (read_sd_card_data(buffer, index, count) != 0)
                    {

                        send( 12 , (char *)buffer, sizeof(MonitorData)*count);
                    }
                }
                else
                {
                    ;
                }
                break;
            }
            case  13 :
            {

                ;
                int count = read_data_size();
                send( 13 , (char *)&count, sizeof(int32_t));
                break;
            }
            default:
            {
                ;
                break;
            }
            }
        }
        else
        {
            ;
            switch (cmd & ~ 128 )
            {
            case  3 :
            {
                ;
                MachineProfile temp;
                if (receive((char *)&temp, sizeof(MachineProfile)))
                {
                    memcpy(machineProfile, &temp,sizeof(MachineProfile));
                    write_sd_profile(machineProfile);
                }
                else
                {
                    ;
                }
                break;
            }
            case  4 :
            {
                ;
                MachineConfiguration configuration;
                if (receive((char *)&configuration, sizeof(MachineConfiguration)))
                {
                    machineProfile->configuration = configuration;
                    ;
                }
                else
                {
                    ;
                }
                break;
            }
            case  5 :
            {
                ;
                MachinePerformance performance;
                if (receive((char *)&performance, sizeof(MachinePerformance)))
                {
                    machineProfile->performance = performance;
                    ;
                }
                else
                {
                    ;
                }
                break;
            }
            case  7 :
            {

                state_machine_set(machineState, PARAM_MOTION_STATUS, MOTIONSTATUS_ENABLED);
                ;
                MotionMode mode;
                if (receive((char *)&mode, sizeof(int)))
                {
                    state_machine_set(machineState, PARAM_MOTION_MODE, mode);
                    ;
                }
                else
                {
                    ;
                }
                break;
            }
            case  8 :
            {
                ;
                int function;
                int data;
                if (receive((char *)&function, sizeof(int)) && receive((char *)&data, sizeof(int)))
                {
                    machineState->_function = function;
                    machineState->_functionData = data;
                    ;
                }
                else
                {
                    ;
                }
                break;
            }
            case  9 :
            {
                ;
                MotionStatus status;
                if (receive((char *)&status, sizeof(int)))
                {
                    state_machine_set(machineState, PARAM_MOTION_STATUS, status);
                    ;
                }
                else
                {
                    ;
                }
                break;
            }
            case  10 :
            {
                ;
                uint8_t buf = 0;
                MotionCommand command;
                if (receive((char*)&command, sizeof(MotionCommand)))
                {
                    if (motion_test_add_move(&command))
                    {
                        buf = 0;
                        send( 11 , (char *)&buf, sizeof(uint8_t));
                    }else
                    {
                        buf = 2;
                        send( 11 , (char *)&buf, sizeof(uint8_t));
                    }
                }
                else
                {
                    buf = 1;
                    send( 11 , (char *)&buf, sizeof(uint8_t));
                    ;
                }
                break;
            }
            default:
            {
                ;
                break;
            }
            }
        }
    }
}

static CommunicationData communicationData;
_Bool  start_communication(MachineProfile *machineProfile, MachineState *machineState, Monitor *monitor, ControlSystem *control)
{
    communicationData.machineProfile = machineProfile;
    communicationData.machineState = machineState;
    communicationData.monitor = monitor;
    communicationData.control = control;


    monitor->cogid =  __builtin_cogstart(beginCommunication(&communicationData), &comm_stack[0]) ;
    if (monitor->cogid != -1)
    {
      return  (1) ;
    }
    return  (0) ;
}
