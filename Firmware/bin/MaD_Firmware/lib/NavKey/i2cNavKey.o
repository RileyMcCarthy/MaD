#line 1 "/home/mad/Tensile-Testing-Machine/Firmware/MaD_Firmware/lib/NavKey/i2cNavKey.c"
#line 15 "/home/mad/Tensile-Testing-Machine/Firmware/MaD_Firmware/lib/NavKey/i2cNavKey.c"
#line 1 "i2cNavKey.h"
#line 19 "i2cNavKey.h"
#line 1 "/home/mad/flexprop/include/stdbool.h"
#line 20 "i2cNavKey.h"
#line 1 "/home/mad/flexprop/include/stdint.h"



typedef signed char int8_t;
typedef unsigned char uint8_t;

typedef signed short int16_t;
typedef unsigned short uint16_t;

typedef signed long int32_t;
typedef unsigned long uint32_t;

typedef long long int64_t;
typedef unsigned long long uint64_t;

typedef unsigned long uintptr_t;
typedef long intptr_t;

typedef int64_t intmax_t;
typedef uint64_t uintmax_t;

typedef int8_t int_least8_t;
typedef int16_t int_least16_t;
typedef int32_t int_least32_t;
typedef int64_t int_least64_t;

typedef uint8_t uint_least8_t;
typedef uint16_t uint_least16_t;
typedef uint32_t uint_least32_t;
typedef uint64_t uint_least64_t;

typedef int32_t int_fast8_t;
typedef int32_t int_fast16_t;
typedef int32_t int_fast32_t;
typedef int64_t int_fast64_t;

typedef uint32_t uint_fast8_t;
typedef uint32_t uint_fast16_t;
typedef uint32_t uint_fast32_t;
typedef uint64_t uint_fast64_t;
#line 21 "i2cNavKey.h"
#line 1 "/home/mad/flexprop/include/stdlib.h"
#line 4 "/home/mad/flexprop/include/stdlib.h"
#line 1 "/home/mad/flexprop/include/compiler.h"
#line 5 "/home/mad/flexprop/include/stdlib.h"
#line 1 "/home/mad/flexprop/include/sys/size_t.h"





  typedef  unsigned long  size_t;
#line 6 "/home/mad/flexprop/include/stdlib.h"
#line 1 "/home/mad/flexprop/include/sys/wchar_t.h"
#line 15 "/home/mad/flexprop/include/sys/wchar_t.h"
typedef int wchar_t;
#line 24 "/home/mad/flexprop/include/sys/wchar_t.h"
typedef struct _Mbstate {
  unsigned int total:5;
  unsigned int left:5;
  unsigned int partial:22;
} _Mbstate_t;
#line 7 "/home/mad/flexprop/include/stdlib.h"
#line 1 "/home/mad/flexprop/include/sys/null.h"
#line 8 "/home/mad/flexprop/include/stdlib.h"
#line 22 "/home/mad/flexprop/include/stdlib.h"
    double atof(const char *);
    int atoi(const char *)  __fromfile("libc/stdlib/atoi.c") ;
    long atol(const char *)  __fromfile("libc/stdlib/atoi.c") ;
    long long atoll(const char *);

  long double strtold(const char *nptr, char **endptr);
  double strtod(const char *nptr, char **endptr);
  float strtof(const char *nptr, char **endptr);

    long strtol(const char *nptr, char **endptr, int base)  __fromfile("libc/stdlib/strtol.c") ;
    unsigned long strtoul(const char *nptr, char **endptr, int base)  __fromfile("libc/stdlib/strtoul.c") ;
  long long strtoll(const char *nptr, char **endptr, int base);
  unsigned long long strtoull(const char *nptr, char **endptr, int base);


    int rand(void)  __fromfile("libc/stdlib/rand.c") ;
    void srand(unsigned int seed)  __fromfile("libc/stdlib/rand.c") ;

    void *malloc(size_t n)  __fromfile("libc/stdlib/malloc.c") ;
    void *calloc(size_t, size_t)  __fromfile("libc/stdlib/malloc.c") ;
    void *realloc(void *, size_t)  __fromfile("libc/stdlib/malloc.c") ;
    void free(void *)  __fromfile("libc/stdlib/malloc.c") ;


    int atexit(void (*func)(void))  __fromfile("libc/stdlib/exit.c") ;
     void exit(int status)  __fromfile("libc/stdlib/exit.c") ;
     void abort(void)  __fromfile("libc/stdlib/abort.c") ;
     void _Exit(int status)  __fromfile("libc/stdlib/_Exit.c") ;
   void _exit(int status);
#line 56 "/home/mad/flexprop/include/stdlib.h"
   long labs(long l);


   long long llabs(long long ll);


  typedef struct {
    int quot, rem;
  } div_t;

  typedef struct {
    long int quot, rem;
  } ldiv_t;

  typedef struct {
    long long quot, rem;
  } lldiv_t;

  div_t div(int num, int denom);
  ldiv_t ldiv(long num, long denom);
  lldiv_t lldiv(long long num, long long denom);

    void qsort(void *base, size_t nmemb, size_t size, int (*compare)(const void *, const void *))  __fromfile("libc/stdlib/qsort.c") ;
  void *bsearch(const void *key, const void *base, size_t nmemb, size_t size,
		int (*compare)(const void *, const void *));

    char *getenv(const char *name)  __fromfile("libc/stdlib/getenv.c") ;
    int putenv(const char *name)  __fromfile("libc/stdlib/putenv.c") ;


  extern int _mb_cur_max;



  int mblen(const char *s, size_t n);
  int mbtowc(wchar_t * __restrict pwc, const char * __restrict s, size_t n);
  size_t mbstowcs(wchar_t *dest, const char *src, size_t n);


  int system(const char *command);
#line 102 "/home/mad/flexprop/include/stdlib.h"
    int _itoa_prec( unsigned int x, char *buf, unsigned base, int prec );
    int _lltoa_prec( unsigned long long x, char *buf, unsigned base, int prec );
#line 22 "i2cNavKey.h"

typedef struct __using("lib/Protocol/jm_i2c.spin2") Bus;


enum GCONF_PARAMETER
{
	FLOAT_DATA = 0x01,
	INT_DATA = 0x00,
	WRAP_ENABLE = 0x02,
	WRAP_DISABLE = 0x00,
	DIRE_LEFT = 0x04,
	DIRE_RIGHT = 0x00,
	IPUP_DISABLE = 0x08,
	IPUP_ENABLE = 0x00,
	CLK_STRECH_ENABLE = 0x10,
	CLK_STRECH_DISABLE = 0x00,
	EEPROM_BANK1 = 0x20,
	EEPROM_BANK2 = 0x00,
	RESET = 0x80,
};

union Data_v
{
	float fval;
	uint16_t wval;
	int32_t val;
	uint8_t bval[4];
};
typedef struct navkeystatus_t
{
	int UPR, UPP, DNR, DNP, RTR, RTP, LTR, LTP;
	int CTRR, CTRP, CTRDP;
	int RINC, RDEC, RMAX, RMIN;
	int GP1POS, GP1NEG, GP2POS, GP2NEG, GP3POS, GP3NEG;
	int FADEINT;
} NavKeyStatus;

typedef struct navkey_t
{
	Bus i2cBus;
	int scl;
	int sda;
	NavKeyStatus status;
	uint8_t _add;
	uint16_t _stat;
	uint8_t _stat2;
	uint8_t _statfade;
	uint8_t _gconf;
	union Data_v _tem_data;
} NavKey;

void navkey_begin(NavKey *navkey, int scl, int sda, uint8_t addr, uint8_t conf);
void navkey_reset(NavKey *navkey);
void navkey_auto_config_interrupt(NavKey *navkey);


void navkey_update_status(NavKey *navkey);

uint8_t navkey_read_gp1_conf(NavKey *navkey);
uint8_t navkey_read_gp2_conf(NavKey *navkey);
uint8_t navkey_read_gp3_conf(NavKey *navkey);
uint16_t navkey_read_interrupt_config(NavKey *navkey);


uint16_t navkey_read_status(NavKey *navkey);

uint8_t navkey_read_int2(NavKey *navkey);

uint8_t navkey_read_fade_status(NavKey *navkey);


float navkey_read_counter_float(NavKey *navkey);
int32_t navkey_read_counter_long(NavKey *navkey);
int16_t navkey_read_counter_int(NavKey *navkey);
int8_t navkey_read_counter_byte(NavKey *navkey);

int32_t navkey_read_max(NavKey *navkey);
float navkey_read_max_float(NavKey *navkey);

int32_t navkey_read_min(NavKey *navkey);
float navkey_read_min_float(NavKey *navkey);

int32_t navkey_readStep(NavKey *navkey);
float navkey_read_step_float(NavKey *navkey);


uint8_t navkey_read_gp1(NavKey *navkey);
uint8_t navkey_read_gp2(NavKey *navkey);
uint8_t navkey_read_gp3(NavKey *navkey);


uint8_t navkey_read_double_push_period(NavKey *navkey);
uint8_t navkey_read_fade_gp(NavKey *navkey);


uint8_t navkey_read_eeprom(NavKey *navkey, uint8_t add);


uint8_t navkey_read_id_code(NavKey *navkey);
uint8_t navkey_read_version(NavKey *navkey);


void navkey_write_gp1_conf(NavKey *navkey, uint8_t gp1);
void navkey_write_gp2_conf(NavKey *navkey, uint8_t gp2);
void navkey_write_gp3_conf(NavKey *navkey, uint8_t gp3);
void navkey_write_interrupt_config(NavKey *navkey, uint16_t interrupt);


void navkey_write_counter(NavKey *navkey, int counter);

void navkey_write_max(NavKey *navkey, int max);

void navkey_write_min(NavKey *navkey, int min);

void navkey_write_step(NavKey *navkey, int step);


void navkey_write_gp1(NavKey *navkey, uint8_t gp1);
void navkey_write_gp2(NavKey *navkey, uint8_t gp2);
void navkey_write_gp3(NavKey *navkey, uint8_t gp3);


void navkey_write_double_push_period(NavKey *navkey, uint8_t dperiod);
void navkey_write_fade_gp(NavKey *navkey, uint8_t fade);

void navkey_write_gamma_gp1(NavKey *navkey, uint8_t gamma);
void navkey_write_gamma_gp2(NavKey *navkey, uint8_t gamma);
void navkey_write_gamma_gp3(NavKey *navkey, uint8_t gamma);


void navkey_writeEEPROM(NavKey *navkey, uint8_t add, uint8_t data);

void navkey_write8(NavKey *navkey, uint8_t reg, uint8_t data);
void navkey_write16(NavKey *navkey, uint8_t reg, uint16_t data);
void navkey_write32(NavKey *navkey, uint8_t reg, int32_t data);
void navkey_write_float(NavKey *navkey, uint8_t reg, float data);
void navkey_write24(NavKey *navkey, uint8_t reg, uint32_t data);
#line 16 "/home/mad/Tensile-Testing-Machine/Firmware/MaD_Firmware/lib/NavKey/i2cNavKey.c"
enum I2C_Register
{
  REG_GCONF = 0x00,
  REG_GP1CONF = 0x01,
  REG_GP2CONF = 0x02,
  REG_GP3CONF = 0x03,
  REG_INTCONFB2 = 0x04,
  REG_INTCONFB1 = 0x05,
  REG_STATUSB2 = 0x06,
  REG_STATUSB1 = 0x07,
  REG_SSTATUS = 0x08,
  REG_FSTATUS = 0x09,
  REG_CVALB4 = 0x0A,
  REG_CVALB3 = 0x0B,
  REG_CVALB2 = 0x0C,
  REG_CVALB1 = 0x0D,
  REG_CMAXB4 = 0x0E,
  REG_CMAXB3 = 0x0F,
  REG_CMAXB2 = 0x10,
  REG_CMAXB1 = 0x11,
  REG_CMINB4 = 0x12,
  REG_CMINB3 = 0x13,
  REG_CMINB2 = 0x14,
  REG_CMINB1 = 0x15,
  REG_ISTEPB4 = 0x16,
  REG_ISTEPB3 = 0x17,
  REG_ISTEPB2 = 0x18,
  REG_ISTEPB1 = 0x19,
  REG_GP1REG = 0x1A,
  REG_GP2REG = 0x1B,
  REG_GP3REG = 0x1C,
  REG_DPPERIOD = 0x1D,
  REG_FADEGP = 0x1E,
  REG_GAMMAGP1 = 0x1F,
  REG_GAMMAGP2 = 0x20,
  REG_GAMMAGP3 = 0x21,
  REG_IDCODE = 0x70,
  REG_VERSION = 0x71,
  REG_EEPROMS = 0x80,
};


enum Int_Status
{
  UPR = 0x0001,
  UPP = 0x0002,
  DNR = 0x0004,
  DNP = 0x0008,
  RTR = 0x0010,
  RTP = 0x0020,
  LTR = 0x0040,
  LTP = 0x0080,
  CTRR = 0x0100,
  CTRP = 0x0200,
  CTRDP = 0x0400,
  RINC = 0x0800,
  RDEC = 0x1000,
  RMAX = 0x2000,
  RMIN = 0x4000,
  INT_2 = 0x8000,
};


enum Int2_Status
{
  GP1_POS = 0x01,
  GP1_NEG = 0x02,
  GP2_POS = 0x04,
  GP2_NEG = 0x08,
  GP3_POS = 0x10,
  GP3_NEG = 0x20,
  FADE_INT = 0x40,
};


enum Fade_Status
{
  FADES_GP1 = 0x01,
  FADES_GP2 = 0x02,
  FADES_GP3 = 0x04,
};


enum GP_PARAMETER
{
  GP_PWM = 0x00,
  GP_OUT = 0x01,
  GP_AN = 0x02,
  GP_IN = 0x03,
  GP_PULL_EN = 0x04,
  GP_PULL_DI = 0x00,
  GP_INT_DI = 0x00,
  GP_INT_PE = 0x08,
  GP_INT_NE = 0x10,
  GP_INT_BE = 0x18,
};

enum GAMMA_PARAMETER
{
  GAMMA_1 = 0,
  GAMMA_1_8 = 1,
  GAMMA_2 = 2,
  GAMMA_2_2 = 3,
  GAMMA_2_4 = 4,
  GAMMA_2_6 = 5,
  GAMMA_2_8 = 6,

};




static uint8_t readNavKeyByte(NavKey *navkey, uint8_t reg)
{
  uint8_t rdata = 0xFF;
#line 138 "/home/mad/Tensile-Testing-Machine/Firmware/MaD_Firmware/lib/NavKey/i2cNavKey.c"
  navkey->_tem_data.val = 0;
  navkey->i2cBus.start();
  navkey->i2cBus.write(navkey->_add & 0b11111110);
  navkey->i2cBus.write(reg);
  navkey->i2cBus.start();
  navkey->i2cBus.write(navkey->_add | 0b00000001);
  rdata = navkey->i2cBus.read(1);
  navkey->i2cBus.stop();

  return rdata;
}


static int16_t readNavKeyInt(NavKey *navkey, uint8_t reg)
{
#line 161 "/home/mad/Tensile-Testing-Machine/Firmware/MaD_Firmware/lib/NavKey/i2cNavKey.c"
  navkey->_tem_data.val = 0;
  navkey->i2cBus.start();
  navkey->i2cBus.write(navkey->_add & 0b11111110);
  navkey->i2cBus.write(reg);
  navkey->i2cBus.start();
  navkey->i2cBus.write(navkey->_add | 0b00000001);
  navkey->_tem_data.bval[1] = navkey->i2cBus.read(0);
  navkey->_tem_data.bval[0] = navkey->i2cBus.read(1);
  navkey->i2cBus.stop();

  return ((int16_t)(navkey->_tem_data.val));
}


static int32_t readNavKeyLong(NavKey *navkey, uint8_t reg)
{
#line 187 "/home/mad/Tensile-Testing-Machine/Firmware/MaD_Firmware/lib/NavKey/i2cNavKey.c"
  navkey->_tem_data.val = 0;
  navkey->i2cBus.start();
  navkey->i2cBus.write(navkey->_add & 0b11111110);
  navkey->i2cBus.write(reg);
  navkey->i2cBus.start();
  navkey->i2cBus.write(navkey->_add | 0b00000001);
  navkey->_tem_data.bval[3] = navkey->i2cBus.read(0);
  navkey->_tem_data.bval[2] = navkey->i2cBus.read(0);
  navkey->_tem_data.bval[1] = navkey->i2cBus.read(0);
  navkey->_tem_data.bval[0] = navkey->i2cBus.read(1);
  navkey->i2cBus.stop();

  return ((int32_t)(navkey->_tem_data.val));
}


static float readNavKeyFloat(NavKey *navkey, uint8_t reg)
{
#line 215 "/home/mad/Tensile-Testing-Machine/Firmware/MaD_Firmware/lib/NavKey/i2cNavKey.c"
  navkey->_tem_data.val = 0;
  navkey->i2cBus.start();
  navkey->i2cBus.write(navkey->_add & 0b11111110);
  navkey->i2cBus.write(reg);
  navkey->i2cBus.start();
  navkey->i2cBus.write(navkey->_add | 0b00000001);
  navkey->_tem_data.bval[3] = navkey->i2cBus.read(0);
  navkey->_tem_data.bval[2] = navkey->i2cBus.read(0);
  navkey->_tem_data.bval[1] = navkey->i2cBus.read(0);
  navkey->_tem_data.bval[0] = navkey->i2cBus.read(1);
  navkey->i2cBus.stop();

  return ((float)navkey->_tem_data.fval);
}


static void writeNavKey8(NavKey *navkey, uint8_t reg, uint8_t data)
{
#line 239 "/home/mad/Tensile-Testing-Machine/Firmware/MaD_Firmware/lib/NavKey/i2cNavKey.c"
  navkey->i2cBus.start();
  navkey->i2cBus.write(navkey->_add & 0b11111110);
  navkey->i2cBus.write(reg);
  navkey->i2cBus.write(data);
  navkey->i2cBus.stop();
}


static void writeNavKey32(NavKey *navkey, uint8_t reg, int32_t data)
{
  navkey->_tem_data.val = data;
#line 259 "/home/mad/Tensile-Testing-Machine/Firmware/MaD_Firmware/lib/NavKey/i2cNavKey.c"
  navkey->i2cBus.start();
  navkey->i2cBus.write(navkey->_add & 0b11111110);
  navkey->i2cBus.write(reg);
  navkey->i2cBus.write(navkey->_tem_data.bval[3]);
  navkey->i2cBus.write(navkey->_tem_data.bval[2]);
  navkey->i2cBus.write(navkey->_tem_data.bval[1]);
  navkey->i2cBus.write(navkey->_tem_data.bval[0]);
  navkey->i2cBus.stop();
}


static void writeNavKey16(NavKey *navkey, uint8_t reg, uint16_t data)
{
  navkey->_tem_data.val = data;
#line 280 "/home/mad/Tensile-Testing-Machine/Firmware/MaD_Firmware/lib/NavKey/i2cNavKey.c"
  navkey->i2cBus.start();
  navkey->i2cBus.write(navkey->_add & 0b11111110);
  navkey->i2cBus.write(reg);
  navkey->i2cBus.write(navkey->_tem_data.bval[1]);
  navkey->i2cBus.write(navkey->_tem_data.bval[0]);
  navkey->i2cBus.stop();
}


static void writeNavKeyFloat(NavKey *navkey, uint8_t reg, float data)
{
  navkey->_tem_data.fval = data;
#line 302 "/home/mad/Tensile-Testing-Machine/Firmware/MaD_Firmware/lib/NavKey/i2cNavKey.c"
  navkey->i2cBus.start();
  navkey->i2cBus.write(navkey->_add & 0b11111110);
  navkey->i2cBus.write(reg);
  navkey->i2cBus.write(navkey->_tem_data.bval[3]);
  navkey->i2cBus.write(navkey->_tem_data.bval[2]);
  navkey->i2cBus.write(navkey->_tem_data.bval[1]);
  navkey->i2cBus.write(navkey->_tem_data.bval[0]);
  navkey->i2cBus.stop();
}


static void writeNavKey24(NavKey *navkey, uint8_t reg, uint32_t data)
{
  navkey->_tem_data.val = data;
#line 324 "/home/mad/Tensile-Testing-Machine/Firmware/MaD_Firmware/lib/NavKey/i2cNavKey.c"
  navkey->i2cBus.start();
  navkey->i2cBus.write(navkey->_add & 0b11111110);
  navkey->i2cBus.write(reg);
  navkey->i2cBus.write(navkey->_tem_data.bval[2]);
  navkey->i2cBus.write(navkey->_tem_data.bval[1]);
  navkey->i2cBus.write(navkey->_tem_data.bval[0]);
  navkey->i2cBus.stop();
}



void navkey_destroy(NavKey *navkey)
{
  free(navkey);
}

void navkey_begin(NavKey *navkey, int scl, int sda, uint8_t addr, uint8_t conf)
{
  navkey->_add = addr;
  navkey->i2cBus.setup(scl, sda, 10, 1);

  writeNavKey8(navkey, REG_GCONF, (uint8_t)0x80);
  _waitms(100);
  writeNavKey8(navkey, REG_GCONF, conf);
  navkey->_gconf = conf;
}
void navkey_reset(NavKey *navkey)

{
  writeNavKey8(navkey, REG_GCONF, (uint8_t)0x80);
  _waitms(10);
}



void navkey_update_status(NavKey *navkey)
{
  int16_t reg = readNavKeyInt(navkey, REG_STATUSB2);
  navkey->status.UPR = reg & UPR;
  navkey->status.UPP = reg & UPP;
  navkey->status.DNR = reg & DNR;
  navkey->status.DNP = reg & DNP;
  navkey->status.RTR = reg & RTR;
  navkey->status.RTP = reg & RTP;
  navkey->status.LTR = reg & LTR;
  navkey->status.LTP = reg & LTP;
  navkey->status.CTRR = reg & CTRR;
  navkey->status.CTRP = reg & CTRP;
  navkey->status.CTRDP = reg & CTRDP;
  navkey->status.RINC = reg & RINC;
  navkey->status.RDEC = reg & RDEC;
  navkey->status.RMAX = reg & RMAX;
  navkey->status.RMIN = reg & RMIN;
}


uint8_t navkey_read_gp1_conf(NavKey *navkey)
{
  return (readNavKeyByte(navkey, REG_GP1CONF));
}


uint8_t navkey_read_gp2_conf(NavKey *navkey)
{
  return (readNavKeyByte(navkey, REG_GP2CONF));
}


uint8_t navkey_read_gp3_conf(NavKey *navkey)
{
  return (readNavKeyByte(navkey, REG_GP3CONF));
}


uint16_t navkey_read_interrupt_config(NavKey *navkey)
{
  return ((uint16_t)readNavKeyInt(navkey, REG_INTCONFB2));
}


uint8_t navkey_read_fade_status(NavKey *navkey)
{
  return readNavKeyByte(navkey, REG_FSTATUS);
}


float navkey_read_counter_float(NavKey *navkey)
{
  return (readNavKeyFloat(navkey, REG_CVALB4));
}


int32_t navkey_read_counter_long(NavKey *navkey)
{
  return (readNavKeyLong(navkey, REG_CVALB4));
}


int16_t navkey_read_counter_int(NavKey *navkey)
{
  return ((int16_t)readNavKeyInt(navkey, REG_CVALB2));
}


int8_t navkey_read_counter_byte(NavKey *navkey)
{
  return ((int8_t)readNavKeyByte(navkey, REG_CVALB1));
}


int32_t navkey_read_max(NavKey *navkey)
{
  return ((int32_t)readNavKeyLong(navkey, REG_CMAXB4));
}


int32_t navkey_read_min(NavKey *navkey)
{
  return ((int32_t)readNavKeyLong(navkey, REG_CMINB4));
}


float navkey_read_max_float(NavKey *navkey)
{
  return (readNavKeyFloat(navkey, REG_CMAXB4));
}


float navkey_read_min_float(NavKey *navkey)
{
  return (readNavKeyFloat(navkey, REG_CMINB4));
}


int32_t navkey_read_step(NavKey *navkey)
{
  return (readNavKeyInt(navkey, REG_ISTEPB4));
}


float navkey_read_step_float(NavKey *navkey)
{
  return (readNavKeyFloat(navkey, REG_ISTEPB4));
}


uint8_t navkey_read_gp1(NavKey *navkey)
{
  return (readNavKeyByte(navkey, REG_GP1REG));
}


uint8_t navkey_read_gp2(NavKey *navkey)
{
  return (readNavKeyByte(navkey, REG_GP2REG));
}


uint8_t navkey_read_gp3(NavKey *navkey)
{
  return (readNavKeyByte(navkey, REG_GP3REG));
}


uint8_t navkey_read_double_push_period(NavKey *navkey)
{
  return (readNavKeyByte(navkey, REG_DPPERIOD));
}


uint8_t navkey_read_fade_gp(NavKey *navkey)
{
  return (readNavKeyByte(navkey, REG_FADEGP));
}


uint8_t navkey_read_eeprom(NavKey *navkey, uint8_t add)
{
  if (add <= 0x7f)
  {
    if ((navkey->_gconf & EEPROM_BANK1) != 0)
    {
      navkey->_gconf = navkey->_gconf & 0xBF;
      writeNavKey8(navkey, REG_GCONF, navkey->_gconf);
    }
    return (readNavKeyByte(navkey, (REG_EEPROMS + add)));
  }
  else
  {
    if ((navkey->_gconf & EEPROM_BANK1) == 0)
    {
      navkey->_gconf = navkey->_gconf | 0x40;
      writeNavKey8(navkey, REG_GCONF, navkey->_gconf);
    }
    return (readNavKeyByte(navkey, add));
  }
}


uint8_t navkey_read_id_code(NavKey *navkey)
{
  return (readNavKeyByte(navkey, REG_IDCODE));
}


uint8_t navkey_read_version(NavKey *navkey)
{
  return (readNavKeyByte(navkey, REG_VERSION));
}



void navkey_write_gp1_conf(NavKey *navkey, uint8_t gp1)
{
  writeNavKey8(navkey, REG_GP1CONF, gp1);
}


void navkey_write_gp2_conf(NavKey *navkey, uint8_t gp2)
{
  writeNavKey8(navkey, REG_GP2CONF, gp2);
}


void navkey_write_gp3_conf(NavKey *navkey, uint8_t gp3)
{
  writeNavKey8(navkey, REG_GP3CONF, gp3);
}


void navkey_write_interrupt_config(NavKey *navkey, uint16_t interrupt)
{
  writeNavKey16(navkey, REG_INTCONFB2, interrupt);
}


void navkey_write_counter(NavKey *navkey, int value)
{
  writeNavKey32(navkey, REG_CVALB4, value);
}


void navkey_write_max(NavKey *navkey, int32_t max)
{
  writeNavKeyFloat(navkey, REG_CMAXB4, max);
}


void navkey_write_min(NavKey *navkey, int32_t min)
{
  writeNavKeyFloat(navkey, REG_CMINB4, min);
}


void navkey_write_step(NavKey *navkey, int32_t step)
{
  writeNavKey32(navkey, REG_ISTEPB4, step);
}


void navkey_write_gp1(NavKey *navkey, uint8_t gp1)
{
  writeNavKey8(navkey, REG_GP1REG, gp1);
}


void navkey_write_gp2(NavKey *navkey, uint8_t gp2)
{
  writeNavKey8(navkey, REG_GP2REG, gp2);
}


void navkey_write_gp3(NavKey *navkey, uint8_t gp3)
{
  writeNavKey8(navkey, REG_GP3REG, gp3);
}


void navkey_write_double_push_period(NavKey *navkey, uint8_t dperiod)
{
  writeNavKey8(navkey, REG_DPPERIOD, dperiod);
}


void navkey_write_fade_gp(NavKey *navkey, uint8_t fade)
{
  writeNavKey8(navkey, REG_FADEGP, fade);
}


void navkey_write_gamma_gp1(NavKey *navkey, uint8_t gamma)
{
  writeNavKey8(navkey, REG_GAMMAGP1, gamma);
}


void navkey_write_gamma_gp2(NavKey *navkey, uint8_t gamma)
{
  writeNavKey8(navkey, REG_GAMMAGP2, gamma);
}


void navkey_write_gamma_gp3(NavKey *navkey, uint8_t gamma)
{
  writeNavKey8(navkey, REG_GAMMAGP3, gamma);
}


void navkey_writeEEPROM(NavKey *navkey, uint8_t add, uint8_t data)
{
  if (add <= 0x7f)
  {
    if ((navkey->_gconf & EEPROM_BANK1) != 0)
    {
      navkey->_gconf = navkey->_gconf & 0xBF;
      writeNavKey8(navkey, REG_GCONF, navkey->_gconf);
    }
    writeNavKey8(navkey, (REG_EEPROMS + add), data);
  }
  else
  {
    if ((navkey->_gconf & EEPROM_BANK1) == 0)
    {
      navkey->_gconf = navkey->_gconf | 0x40;
      writeNavKey8(navkey, REG_GCONF, navkey->_gconf);
    }
    writeNavKey8(navkey, add, data);
  }
}
